---
// Animación tipo "Matrix" revelada solo alrededor del cursor cuando se mueve
---

<canvas id="matrix-canvas"></canvas>

<style>
	#matrix-canvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		pointer-events: none;
		/* Sutil para no competir con el contenido */
		opacity: 0.35;
	}
</style>

<script>
	const canvas = document.getElementById('matrix-canvas') as HTMLCanvasElement;
	const ctx = canvas.getContext('2d')!;

	let width = 0;
	let height = 0;
	const dpr = Math.max(1, window.devicePixelRatio || 1);

	// Offscreen para componer el efecto sin ensuciar el lienzo principal
	const offscreen = document.createElement('canvas');
	const off = offscreen.getContext('2d')!;

	// Parámetros del efecto
	let fontSize = 16; // en CSS px
	let columns = 0;
	let drops: number[] = [];
	const glyphs = 'アイウエオカキクケコサシスセソタチツテトナニヌネノ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&*';

	// Revealing mask
	let mouseX = 0;
	let mouseY = 0;
	let lastX = 0;
	let lastY = 0;
	let lastMoveTs = 0;
	let reveal = false;

	function resize() {
		width = canvas.clientWidth;
		height = canvas.clientHeight;
		canvas.width = Math.floor(width * dpr);
		canvas.height = Math.floor(height * dpr);
		ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

		offscreen.width = Math.floor(width * dpr);
		offscreen.height = Math.floor(height * dpr);
		off.setTransform(dpr, 0, 0, dpr, 0, 0);

		fontSize = Math.max(14, Math.min(22, Math.round(width / 70)));
		off.font = `${fontSize}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
		off.textBaseline = 'top';
		columns = Math.ceil(width / fontSize);
		drops = new Array(columns).fill(0);
	}

	function drawMatrix() {
		// Desvanecer suavemente el contenido anterior del offscreen sin pintar negro
		off.globalCompositeOperation = 'destination-out';
		off.fillStyle = 'rgba(0,0,0,0.08)';
		off.fillRect(0, 0, width, height);
		off.globalCompositeOperation = 'source-over';

		off.fillStyle = '#8B7355';
		for (let i = 0; i < columns; i++) {
			const char = glyphs[Math.floor(Math.random() * glyphs.length)];
			const x = i * fontSize;
			const y = drops[i] * fontSize;
			off.fillText(char, x, y);
			if (y > height && Math.random() > 0.975) {
				drops[i] = 0;
			} else {
				drops[i]++;
			}
		}
	}

	function render() {
		// Siempre actualizar el offscreen para que el efecto tenga vida
		drawMatrix();

		const now = performance.now();
		reveal = now - lastMoveTs < 180; // Solo revelar si hubo movimiento reciente

		// Limpiar el canvas principal
		ctx.clearRect(0, 0, width, height);

		if (reveal) {
			// Pintar la capa de símbolos
			ctx.globalCompositeOperation = 'source-over';
			ctx.drawImage(offscreen, 0, 0, width, height);

			// Aplicar máscara radial alrededor del cursor
			const dx = mouseX - lastX;
			const dy = mouseY - lastY;
			const speed = Math.min(1, Math.hypot(dx, dy) / 40);
			const radius = 110 + speed * 90; // más grande cuanto más rápido se mueve

			ctx.globalCompositeOperation = 'destination-in';
			const g = ctx.createRadialGradient(mouseX, mouseY, radius * 0.3, mouseX, mouseY, radius);
			g.addColorStop(0, 'rgba(255,255,255,1)');
			g.addColorStop(1, 'rgba(255,255,255,0)');
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, width, height);
		}

		lastX = mouseX;
		lastY = mouseY;
		requestAnimationFrame(render);
	}

	function onMove(e: MouseEvent) {
		const rect = canvas.getBoundingClientRect();
		mouseX = e.clientX - rect.left;
		mouseY = e.clientY - rect.top;
		lastMoveTs = performance.now();
	}

	window.addEventListener('resize', resize);
	window.addEventListener('mousemove', onMove);
	resize();
	requestAnimationFrame(render);

	// Limpieza al navegar
	document.addEventListener('astro:before-swap', () => {
		window.removeEventListener('resize', resize);
		window.removeEventListener('mousemove', onMove);
	});
</script>


